package gametheory.assignment2.students20s;

import gametheory.assignment2.Player;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class YusufMesbahCode implements Player {
    final int history_size = 10;
    final double[] intercept = {0.0054722329, 0.0695512688, -0.0750235017};
    int prev = 0, counter = 0;
    int[][] opponent_history;
    int[][] my_history;
    double[][] coef = {
            {0.21038820820025303, -0.34453348829760794, 0.13371556869854873},
            {-0.13613591732044233, 0.45103243622978956, -0.31502721227937197},
            {0.02429836588053583, -0.11155377344829509, 0.08696891247461534},
            {-0.3756684624494388, 0.11219791455173642, 0.2636287473136232},
            {0.25171265308312235, -0.3258689875151988, 0.07414026293950543},
            {0.10798867633375274, 0.26587814555782147, -0.374010126813047},
            {-0.11748065985053123, 0.1291842894159117, -0.011507935920334408},
            {0.08594280538195305, -0.03717734384205211, -0.04844801615849461},
            {-0.03786562873865047, -0.09651628851186324, 0.13475641212365527},
            {-0.2823323514308918, 0.20293797416001416, 0.07925755016387849},
            {0.16559465635775134, -0.263057826295531, 0.09753101958116656},
            {0.06871307966364537, 0.14259756971495982, -0.21143814914507889},
            {0.19160431227244065, -0.08639772459344014, -0.10475842950856558},
            {-0.11431946913395696, 0.19997419256654173, -0.08555123562863773},
            {-0.058992037430207124, -0.07874121146537955, 0.13818277121077727},
            {-0.36067931769335093, -0.033650998794611406, 0.3947798444851023},
            {0.06611157632903007, 0.035593418727952984, -0.10135287404186283},
            {0.24013026171093943, 0.05546045761995775, -0.29573269568684496},
            {0.2234792027725199, 0.06565275143199696, -0.28926786925890824},
            {-0.0004831233531208234, 0.016166053514576617, -0.01559543936931079},
            {-0.1580297522241529, -0.0021092721775088324, 0.1605882383615309},
            {-0.25036903921423215, 0.013034830702990696, 0.23762408130885398},
            {0.2779143184002703, -0.4896282969322345, 0.21156375457238288},
            {0.034616640294268294, 0.4513018673563935, -0.48605918527589803},
            {-0.20496659686402807, -0.12234160583508916, 0.32767277578888293},
            {0.12786658029253783, 0.16541309426963283, -0.29330226396136677},
            {0.18629960596148565, -0.10607038964296285, -0.07978215456667917},
            {-0.22318613733833928, 0.04456043402395245, 0.1785805590182451},
            {0.05629855713227315, 0.08194662082299176, -0.13805691325115826},
            {0.002538508423463693, -0.0811801449792707, 0.07892044577431606},
            {0.060308848653443166, -0.1170205596030077, 0.05670895761078153},
            {0.14738394007008074, 0.0809775266488992, -0.2281776283376329},
            {-0.35618948603509293, 0.014983522457718746, 0.34152891330693086},
            {-0.08379830699383145, 0.036357401303882715, 0.047296226236738265},
            {0.07236827153765263, -0.12332068945005427, 0.05050289276007417},
            {-0.02321139186140483, 0.12171868247877331, -0.09821224759715075},
            {-0.3694414505104166, 0.12459677051807037, 0.24454516555217443},
            {0.14178427048742592, -0.13896379359031155, -0.002686839597532992},
            {0.18195678799826795, 0.07055422183816142, -0.25250499744600446},
            {0.11726797064139736, -0.12178111514175366, 0.0044640191985445155},
            {-0.2746654987143374, 0.2603518932261843, 0.014053447710013224},
            {0.12345133416814884, -0.1033494425752026, -0.02000188896502425},
            {-0.4397474027707737, 0.2904637771883801, 0.14923578271973148},
            {0.21356400621628172, -0.40018170750923615, 0.18616817615115253},
            {0.20663037059861428, 0.14527696427081857, -0.3519078590069311},
            {-0.24997243773711939, -0.12266867680613096, 0.37291399693158883},
            {0.11448574800854727, 0.2100796084428258, -0.32494554741743087},
            {0.12466551918504319, -0.07000286300612645, -0.05449285406996699},
            {-0.12862126130801652, 0.14922126792170717, -0.020343815171645168},
            {-0.035130665551981494, -0.0664473161773595, 0.10134192501047602},
            {0.15622291386502524, -0.0661193337278378, -0.08982231781698134},
            {-0.2052842319222526, 0.12843470803448362, 0.07692709482278448},
            {0.0011286661948955257, 0.032238649593105274, -0.033779043896230806},
            {0.22375711021465652, -0.16610646878423813, -0.05761350924233147},
            {-0.32502955322802035, 0.20809741401095613, 0.11665045412085524},
            {0.2421025418647417, -0.2573934184921644, 0.015081774724119356},
            {0.07597334791034445, 0.06499965359230882, -0.14097094435755153},
            {-0.5136336053787736, -0.13342534199513964, 0.6473100351186346},
            {0.17755893464713604, -0.0074630484660959725, -0.169958667469856},
            {0.3806785175728944, 0.13174552446435672, -0.5124101185123621},
            {-0.2826025914870457, 0.1925246744235852, 0.08987613921569772},
            {0.16594751300020558, -0.3806770646610096, 0.21428002651680267},
            {0.12730237953008552, 0.2439987827199972, -0.3712963987160198},
    };

    public YusufMesbahCode() {
        reset();
    }

    int[] one_hot(int move) {
        int[] ret = {0, 0, 0};
        if (move != 0)
            ret[move - 1] = 1;
        return ret;
    }

    @Override
    public void reset() {
        prev = 0;
        counter = 0;
        opponent_history = new int[history_size][3];
        my_history = new int[history_size][3];
    }

    int predict(List<Integer> features) {
        double[] sums = intercept.clone();

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 2 * 3 * history_size + 3; j++) {
                sums[i] += features.get(j) * coef[j][i];
            }
        }

        if (sums[0] >= sums[1] && sums[0] >= sums[2])
            return 1;
        if (sums[1] >= sums[2])
            return 2;
        return 3;
    }

    // taken from https://www.geeksforgeeks.org/how-to-get-slice-of-a-primitive-array-in-java/
//    public static int[] getSliceOfArray(int[] arr, int start, int end)
//    {
//        // Get the slice of the Array
//        int[] slice = new int[end - start];
//        // Copy elements of arr to slice
//        for (int i = 0; i < slice.length; i++) {
//            slice[i] = arr[start + i];
//        }
//        // return the slice
//        return slice;
//    }
    // taken from https://stackoverflow.com/questions/25513833/java-append-element-to-primitive-array
    int[][] appendAndCut(int[][] array, int[] x) {
        int[][] result = new int[array.length][3];
        for (int i = 0; i < array.length - 1; i++) {
            result[i] = array[i + 1].clone();
        }
//        if (array.length >= 1) System.arraycopy(array, 1, result, 0, array.length - 1);
        result[result.length - 1] = x.clone();
        return result;
    }

    @Override
    public int move(int opponentLastMove, int xA, int xB, int xC) {
//        System.out.println("Moving");
        opponent_history = appendAndCut(opponent_history, one_hot(opponentLastMove));
        List<Integer> features = new ArrayList<>(Arrays.asList(xA, xB, xC));
        for (int i = 0; i < history_size; i++)
            Collections.addAll(features, opponent_history[i][0], opponent_history[i][1], opponent_history[i][2]);
        for (int i = 0; i < history_size; i++)
            Collections.addAll(features, my_history[i][0], my_history[i][1], my_history[i][2]);
        int ret = predict(features);
        my_history = appendAndCut(my_history, one_hot(ret));

//        for (int i = 0; i < 63; i++)
//            System.out.println(features.get(i));
//        System.out.println(features.size());
//        System.out.println("\n");

        return ret;
//
//        counter++;
//        if (counter > 2)
//            prev = 1;
//        else if (prev != 1 && prev != opponentLastMove){
//            counter = 0;
//            prev = 1;
//        }
//        else if (prev != 1 && prev == opponentLastMove) {
//            counter = 0;
//            prev = (opponentLastMove == 2) ? 3 : 2;
//        }
//        else
//            prev = ThreadLocalRandom.current().nextInt(2, 3 + 1);
//        return prev;
    }

    @Override
    public String getEmail() {
        return "y.mesbah@innopolis.university";
    }
}
